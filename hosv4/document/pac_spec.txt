------------------------------------------------------------------------------
  HOS-V4                                                                      
    他プロセッサ移植用資料                                                    
                                                                              
                                       Copyright (C) 1998-2002 by Project HOS 
                                       http://sourceforge.jp/projects/hos/    
------------------------------------------------------------------------------


1. 概要
  HOS-V4 の本体はプロセッサへの依存性を排し、極力 ANSI-C にのっとって、
多くのCコンパイラでコンパイルできることを目的として書かれています。
  一方で、実際に HOS-V4 を動作させる為には、プロセッサや周辺LSIに依存した
部分を記述する必要があります。
  本資料には HOS-V4 を実際のプロセッサで動かす為に必要な情報を記載します。


2. プロセッサ抽象化コンポーネント

2.1 概要

  プロセッサに依存する部分を、吸収する為にカーネルはヘッダファイル
 hospac.h を読み込んでコンパイルされます。
  hospac.h はプロセッサ毎に用意され、コンパイル時のインクルードパス
指定を切り替えることで制御されます。
  カーネルが利用する関数は以下の通りです。

  hospac_ini_sys   初期化
  hospac_dis_int   割り込み禁止
  hospac_ena_int   割り込み許可
  hospac_cre_ctx   実行コンテキスト作成
  hospac_swi_ctx   実行コンテキスト切り替え
  hospac_set_tex   例外処理実行設定
  hospac_idle      アイドル時処理

  これらの関数はコンパイル時に解決される為にマクロを利用する事も
可能です。
  また、hospac.h では typedef によって T_HOSPAC_CTXINF を宣言
しておく必要があります。
  これはタスクの実行状態を保存出来るデータ型として定義してください。
カーネルは T_HOSPAC_CTXINF の中身については一切関与しません。必要な
データをいくつでも格納することが出来ます。
  通常はスタックポインタや、退避の必要なレジスタ用の変数を有した
構造体になるかと思います。


2.2 初期化

  カーネル起動時に hospac_ini_sys が呼ばれます。プロセッサ固有の初期化の
必要があればここで行ってください。
  必要なければ #define で hospac_ini_sys() を空に宣言しても構いません。


2.3 割り込み制御

  hospac_ena_int、hospac_dis_int が呼ばれた際は割り込みを許可／禁止
してください。
  インラインアセンブラなど利用できる場合はマクロ宣言でも問題は
ありませんが、インラインアセンブラを利用する際は利用するレジスタが
他のC言語部分を壊さないよう、処理系の仕様を良く読んで行ってください。


2.4 コンテキスト制御

  実際のタスクコンテキストを作成する為にカーネルは hospac_cre_ctx
を呼び出します。
  
  void hospac_cre_ctx(
        T_HOSPAC_CTXINF *pk_ctxinf,  /* コンテキスト情報格納先の先頭番地 */
        VP_INT          exinf,       /* 起動時引数 */
        FP              task,        /* 起動番地 */
        SIZE            stksz,       /* スタックサイズ */
        VP              stk          /* スタック先頭番地 */
      );

  次回、hospac_swi_ctx で指定された場合に、task を 引数 exinf として
呼び出すようにコンテキストを作成してください。
  taskで指定する関数のアドレスは

  void task(VP_INT exinf);

  で定義される形式です。


  次に hospac_swi_ctx の宣言を示します。

  void hospac_swi_ctx(
        T_HOSPAC_CTXINF *pk_pre_ctxinf,  /* 現在のコンテキストの保存先 */
        T_HOSPAC_CTXINF *pk_nxt_ctxinf   /* 切り替える先のコンテキスト */
       );

  hospac_swi_ctx を呼び出すと、現在の実行状態を pk_pre_ctxinf に
保存してください。
  その後、pk_nxt_ctxinf に保存されている実行状態を再開するように
してください。


2.5 例外処理

  カーネルは例外処理を行うために hospac_set_tex を呼び出します。
  pk_ctxinf で指定されたコンテキストを、次回 hospac_swi_ctx
で切り替えられた際に exp で指定された関数を引数 rasptn として
実行できるように設定する必要があります。
  また、例外処理からリターンすると、自動的に元の関数に戻るように
してください。


2.6 アイドル処理

  実行タスクが無い場合 カーネルは
  
  for ( ; ; )
  {
      hospac_idle();
  }
  
  を実行します。プロセッサによっては、アイドル時に HALT させるなどで
消費電力を落とすなどの処理を行うことが可能です。
  特にそのような機能が不要の場合は、マクロで削除することも可能です。




3. 割り込み処理

3.1 割り込みハンドラ

  割り込み発生時に呼び出す必要のあるカーネル関数は以下の通りです。

  void kernel_sta_int(void);        /* 割り込み処理の開始 */
  void kernel_end_int(void);	    /* 割り込み処理の終了 */
  void kernel_exe_int(INTNO intno); /* 割り込み処理の実行 */

  初回割り込み時に行うべき処理を以下に示します。

  (1) 割り込み用スタックに入れ替える
  (2) kernel_sta_int 関数を呼び出す
  (3) kernel_exe_int 関数を呼び出す
  (4) kernel_end_int 関数を呼び出す
  (5) 割り込みハンドラから復帰する

  ここで、(1)の割り込み用スタック領域はコンフィギュレーターによって

  const VP kernel_int_sp;

  の形で宣言されているポインタ変数に格納されていますので
利用出来ます。ポインタアドレス値がエクスポートされているの
ではなく、ポインタアドレスが格納されたポインタ変数のアドレスが
エクスポートされている点に注意してください。

  次に、(2)の関数呼び出しで、カーネル内部の状態変数が、非タスク部
実行中に切り替えられます。
  また、kernel_sta_int 関数の内部で hospac_ena_int() 関数が呼ばれ、
多重割り込みが許可されます。
  逆に kernel_sta_int 関数呼び出しまでは割り込み禁止状態を保つ
必要があります。

  もし、多重割り込みを許可したくない場合は、フラグ変数などを
別途用意して hospac_ena_int() が呼ばれても割り込みを許可しな
いようにマスクしてください。

  (3)の関数呼び出しで、実際に ATT_ISR などで登録した割り込み
サービスルーチンが呼び出されます。割り込み番号を引数として
呼び出してください。
  割り込みコントローラーによって、必要に応じて (3) の前後で
割り込みの開始、終了時の処理を行ってください。
  ここでソフトウェア的に割り込みマスクを設定してレベル割り込み
を実現することも可能です。

  最後に (4) の関数の中で必要に応じて遅延ディスパッチが
発生します。
  即ち、(4)の段階までには、プロセッサモードは通常のタスクと
同じ実行状態にしておく必要があります。
  シンプルな CPU(Z80 や H8 など) の場合は問題ありませんが、
割り込み専用の実行モードを備えたプロセッサ(386 や ARM など)の
場合は注意が必要です。

  また、多重割り込みに対応する場合は、多重割り込み時は単に
kernel_exe_int 関数を呼び出すのみとなります。
  多重割り込み時に kernel_sta_int や kernel_end_int を呼び
出さないで下さい。


3.1 割り込み制御

  ITRONのサービスコールとして、ena_int、dis_int、chg_ixx、
get_ixx などがありますが、これは割り込みコントローラーに
依存する機能であるため、カーネルでは実装していません。
  必要であればユーザー側で用意してください。



------------------------------------------------------------------------------
 Copyright (C) 1998-2002 by Project HOS                                       
------------------------------------------------------------------------------
